<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    .li {
      border-bottom: 1px solid #ccc;
    }

    .li:hover span:after {
      content: 'xxxxxx'
    }

    label {
      cursor: pointer;
    }

    input[type="checkbox"]:checked+span {
      color: red;
    }

    #a {}

    .sd {
      border: none;
    }


    .test {
      width: 100px;
      height: 100px;
      transition: all .5s;
      transform-origin: right bottom;
      border: 1px solid #ccc;
      transform: scale(0)
    }

    .mm:hover .test {
      transform: scale(1);
    }

    .a {
      border-top: 1px solid #ddd;
      width: 100px;
      height: 100px;
      line-height: 100px;
      text-align: center;
    }

    .b {
      width: 100px;
      height: 100px;
      line-height: 100px;
      text-align: center;
      position: relative;
    }

    .border-left-1px,
    .border-right-1px {
      /* position: relative; */
    }

   

    .border-right-1px:after {
      content: '';
      display: block;
      border-right: 1px solid #ddd;
      transform: scale(0.5);
      position: absolute;
      right: 0;
      bottom: 0;
      height: 200%;
      transform-origin: right 0;
    }

    .border-top-1px:after {
      content: '';
      display: block;
      border-top: 1px solid #ddd;
      transform: scale(0.5);
      position: absolute;
      left: 0;
      top: 0;
      width: 200%;
      transform-origin: 0 top;
    }

    .border-bottom-1px:before {
      content: '';
      display: block;
      border-bottom: 1px solid #ddd;
      transform: scale(0.5);
      position: absolute;
      right: 0;
      bottom: 0;
      width: 200%;
      transform-origin: 0 bottom;
    }

     .border-left-1px:before {
      content: '';
      display: block;
      border-left: 1px solid #ddd;
      transform: scale(0.5);
      position: absolute;
      left: 0;
      top: 0;
      height: 200%;
      transform-origin: left 0;
    }
  </style>
</head>

<body>


  <div class="a">ddddddddddd</div>
  <div class="b border-bottom-1px  "></div>

  <div class="mm">sdzzz
    <div class="test"></div>
  </div>



  <div style="width: 240px;display: flex;margin-bottom: 23px;justify-content: space-between;
  align-items: center;">
    <span>验证码</span>
    <input class="sd" type="text" placeholder="sadad">

  </div>
  <input type="text" placeholder="wqeqw">

  <div id="a" style="transition: all 0.5s;
  transform: scale(0.2);
  font-size: 100px;display:none;">sd</div>
  <span onclick="a()">sad</span>
  <div class="li">
    <span>1</span>
  </div>
  <div class="li">
    <span>1</span>
  </div>
  <div class="li">
    <span>1</span>
  </div>
  <div class="li">
    <span>1</span>
  </div>
  <div class="li">
    <span>1</span>
  </div>

  <label>
    <input type="checkbox">
    <span>2222</span>
  </label>
  <label>
    <input type="checkbox">3333</label>
  <label>
    <input type="checkbox">4444</label>
  <label>
    <input type="checkbox">5555</label>
  <video controls id="video"></video>
</body>

</html>

<script>
  let video = document.getElementById('video')

  // fetch('http://localhost:5000/api/pic').then(async res => {
  //   let pic = await res.blob()
  //   // pic = new Blob(pic,{type:"application/octet-stream"})
  //   console.log(pic)
  //   var objectURL = URL.createObjectURL(pic)
  //   var img = new Image()
  //   // let reader = new FileReader()
  //   // reader.readAsDataURL(pic)
  //   // reader.addEventListener("load", function () {
  //   //   console.log(reader)
  //   //   img.src = reader.result
  //   // }, false)

  //   video.src = objectURL
  //   // img.style.width="500px"
  //   // document.body.appendChild(img)
  //   // console.log(objectURL)
  // })

  function a() {
    return new Promise((resolve, reject) => {
      fetch('https://cnodejs.org/api/v1/topics').then(res => {
        // console.log('res',res.json())
        let a = res.json()
        if (a) {
          resolve(a)
        } else {
          reject('err')
        }

      })
    })
  }
  async function test() {

    // return new Promise((resolve, reject) => {
    let d = await fetch('http://localhost:5000/api/good/categorys')
    return d.json()
    // console.log(d)
    // return d
    // })


  }

  // test()

  async function test1() {
    return 'xxx'
  }

  async function x() {
    // for (let i = 0; i < 3; i++) {
    //   console.log(await test())
    // }

    // console.log('finished')
    let [x, y, z] = await Promise.all([test(), test(), test()])
    console.log(x, y, z)
    console.log('123123')
  }

  x()

  // x()
  // let list = document.getElementsByTagName('input')
  // let label = document.getElementsByTagName('label')
  // for (let index = 0; index < label.length; index++) {
  //   label[index].onclick = (e) => {
  //     console.log(1)
  //     // e.stopPropagation()
  //   }

  // }

  class EventEmeitter {
    constructor() {
      this._events = this._events || new Map(); // 储存事件/回调键值对
      this._maxListeners = this._maxListeners || 10; // 设立监听上限
    }
  }

  // 触发名为type的事件
  EventEmeitter.prototype.emit = function (type, ...args) {
    let handler;
    handler = this._events.get(type);
    console.log(handler, this)
    if (Array.isArray(handler)) {
      // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数
      for (let i = 0; i < handler.length; i++) {
        if (args.length > 0) {
          handler[i].apply(this, args);
        } else {
          handler[i].call(this);
        }
      }
    } else { // 单个函数的情况我们直接触发即可
      if (args.length > 0) {
        handler(args);
      } else {
        handler();
      }
    }

    return true;
  };

  // 监听名为type的事件
  EventEmeitter.prototype.addListener = function (type, fn) {
    const handler = this._events.get(type); // 获取对应事件名称的函数清单
    if (!handler) {
      this._events.set(type, fn);
    } else if (handler && typeof handler === 'function') {
      // 如果handler是函数说明只有一个监听者
      this._events.set(type, [handler, fn]); // 多个监听者我们需要用数组储存
    } else {
      handler.push(fn); // 已经有多个监听者,那么直接往数组里push函数即可
    }
  };
  EventEmeitter.prototype.removeListener = function (type, fn) {
    const handler = this._events.get(type); // 获取对应事件名称的函数清单

    // 如果是函数,说明只被监听了一次
    if (handler && typeof handler === 'function') {
      this._events.delete(type, fn);
    } else {
      let postion;
      // 如果handler是数组,说明被监听多次要找到对应的函数
      for (let i = 0; i < handler.length; i++) {
        if (handler[i] === fn) {
          postion = i;
        } else {
          postion = -1;
        }
      }
      // 如果找到匹配的函数,从数组中清除
      if (postion !== -1) {
        // 找到数组对应的位置,直接清除此回调
        handler.splice(postion, 1);
        // 如果清除后只有一个函数,那么取消数组,以函数形式保存
        if (handler.length === 1) {
          this._events.set(type, handler[0]);
        }
      } else {
        return this;
      }
    }
  };

  let em = new EventEmeitter()
  em.addListener('a', function (name) {
    this.name = name
    console.log(this)
  })

  em.emit('a', 'mxx')

</script>